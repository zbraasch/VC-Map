<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Japanese Venture Capital Firms — Interactive Map</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.2.0/ol.css" />

  <style>
    :root{
      --bg:#f6f7f9;
      --card:#ffffff;
      --text:#0b1320;
      --muted:#6b7280;
      --border:#e5e7eb;
      --shadow:0 12px 28px rgba(15, 23, 42, .08);
      --radius:22px;
      --link:#2563eb;
      --ok:#16a34a;
      --bad:#dc2626;
      --pending:#6b7280;
      --card-padding:16px;
      --hover:#f1f5f9;
    }

    [data-theme="dark"]{
      --bg:#0f172a;
      --card:#1e293b;
      --text:#f1f5f9;
      --muted:#94a3b8;
      --border:#334155;
      --shadow:0 12px 28px rgba(0, 0, 0, .4);
      --link:#60a5fa;
      --hover:#334155;
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    *{box-sizing:border-box; margin:0; padding:0;}
    a{color:var(--link); text-decoration:none;}
    a:hover{text-decoration:underline;}

    /* Top nav */
    .topbar{
      position:fixed; inset:0 0 auto 0; height:64px; z-index:30;
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 14px;
      background:var(--bg);
      border-bottom:1px solid var(--border);
    }
    .leftGroup, .rightGroup{display:flex; align-items:center; gap:10px;}
    .iconBtn{
      height:44px; width:44px; border-radius:14px;
      border:1px solid transparent;
      background:transparent;
      display:grid; place-items:center;
      cursor:pointer;
      color:var(--text);
      transition: background .12s ease, border-color .12s ease, transform .12s ease;
    }
    .iconBtn:hover{background:var(--card); border-color:var(--border); transform:translateY(-1px);}
    .iconBtn:active{transform:translateY(0);}

    .titleBlock{min-width:0;}
    .title{
      font-weight:800; letter-spacing:-.2px;
      font-size:16px; line-height:1.1;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin:0;
    }
    .subtitle{
      margin:2px 0 0 0;
      color:var(--muted); font-size:12px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .countChips{display:flex; align-items:center; gap:6px; cursor:pointer;}
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:5px 8px;
      border-radius:999px;
      background:var(--card);
      border:1px solid var(--border);
      box-shadow:0 2px 10px rgba(15,23,42,.04);
      font-size:11px;
      color:var(--muted);
      user-select:none;
      cursor:pointer;
    }
    .dot{width:8px; height:8px; border-radius:999px; display:inline-block;}
    .dot.ok{background:var(--ok);}
    .dot.no{background:var(--bad);}
    .dot.pending{background:#9ca3af;}
    .statusPill.pending .dot{animation:pulse 1s ease-in-out infinite;}
    @keyframes pulse{
      0%, 100%{opacity:1;}
      50%{opacity:0.4;}
    }

    .pillBtn{
      border:1px solid var(--border);
      background:var(--card);
      height:44px;
      padding:0 14px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      gap:10px;
      cursor:pointer;
      box-shadow:0 2px 10px rgba(15,23,42,.04);
      transition:transform .12s ease, background .12s ease;
      font-size:13px;
      font-weight:600;
    }
    .pillBtn:hover{transform:translateY(-1px);}
    .pillBtn.primary{
      background:#eef2ff;
      border-color:#c7d2fe;
      color:#1e40af;
    }

    /* Map fills background */
    #map{
      position:fixed;
      top:64px;
      right:0;
      bottom:0;
      left:0;
      z-index:1;
      transition:left .20s ease;
    }

    /* Drawer */
    .overlay{
      position:fixed; inset:0;
      z-index:40;
      background:rgba(15,23,42,.25);
      opacity:0; pointer-events:none;
      transition:opacity .18s ease;
    }
    .overlay.open{opacity:1; pointer-events:auto;}

    .drawer{
      position:fixed; top:64px; bottom:0; left:0;
      width:min(520px, calc(100vw - 26px));
      z-index:50;
      transform:translateX(-106%);
      transition:transform .20s ease;
      background:var(--bg);
      border-right:1px solid var(--border);
      box-shadow:var(--shadow);
      display:flex; flex-direction:column;
    }
    .drawer.open{transform:translateX(0);}

    .drawerHeader{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 14px 10px 14px;
    }
    .drawerHeader h2{margin:0; font-size:16px; font-weight:800; letter-spacing:-.2px;}
    .drawerBody{
      padding:12px 14px 18px 14px;
      overflow-y:auto;
      overflow-x:hidden;
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:stretch;
    }
    /* Prevent scrollbar from shifting content */
    @supports (overflow-y: overlay) {
      .drawerBody {
        overflow-y: overlay;
      }
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:0 2px 14px rgba(15,23,42,.05);
      width:100%;
    }
    .cardHead{
      padding:14px var(--card-padding);
      min-height:56px;
      font-weight:800;
      letter-spacing:-.2px;
      font-size:14px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      user-select:none;
      transition:background .12s ease;
      box-sizing:border-box;
    }
    .cardHead .chevron{
      transition:transform .2s ease;
      color:var(--muted);
    }
    .sectionTitle{
      min-width:85px;
      display:inline-block;
    }
    .card.expanded .cardHead .chevron{
      transform:rotate(180deg);
    }
    .cardBody{
      padding:0 var(--card-padding) 16px var(--card-padding);
      display:none;
      box-sizing:border-box;
    }
    .card.expanded .cardBody{
      display:block;
    }

    label{display:block; color:var(--muted); font-size:12px; margin-bottom:8px;}
    input[type="text"], input[type="number"]:not(.settingInput){
      width:100%;
      padding:14px 14px;
      border-radius:16px;
      border:1px solid var(--border);
      background:var(--bg);
      color:var(--text);
      outline:none;
    }
    input[type="text"]:focus, input[type="number"]:not(.settingInput):focus{
      border-color:#c7d2fe;
      box-shadow:0 0 0 4px rgba(99,102,241,.12);
      background:var(--card);
    }

    .btnRow{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:16px;}
    .btn{
      height:44px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--card);
      color:var(--text);
      cursor:pointer;
      font-weight:650;
      font-size:13px;
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      box-shadow:0 2px 10px rgba(15,23,42,.04);
      transition: transform .12s ease, background .1s ease, box-shadow .1s ease;
    }
    .btn:hover{transform:translateY(-1px);}
    .btn:active{
      transform:translateY(1px);
      box-shadow:0 1px 4px rgba(15,23,42,.08);
      background:#f1f5f9;
    }
    [data-theme="dark"] .btn:active{
      background:#334155;
    }
    .btn.primary:active{
      background:#c7d2fe;
    }
    [data-theme="dark"] .btn.primary:active{
      background:#4338ca;
    }
    .btn.danger:active{
      background:#fecdd3;
    }
    [data-theme="dark"] .btn.danger:active{
      background:#9f1239;
    }
    .btn.primary{
      background:#eef2ff;
      border-color:#c7d2fe;
      color:#1e40af;
    }
    [data-theme="dark"] .btn.primary{
      background:#3730a3;
      border-color:#4f46e5;
      color:#e0e7ff;
    }
    .btn.danger{
      background:#fff1f2;
      border-color:#fecdd3;
      color:#9f1239;
    }
    [data-theme="dark"] .btn.danger{
      background:#7f1d1d;
      border-color:#b91c1c;
      color:#fecaca;
    }

    .hint{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    .progressContainer{
      display:none;
      margin-top:16px;
      padding:14px 16px;
      background:var(--bg);
      border:1px solid var(--border);
      border-radius:16px;
    }
    .progressContainer.active{
      display:block;
    }
    .progressLabel{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:10px;
      font-size:13px;
      font-weight:600;
    }
    .progressLabel .status{
      color:var(--muted);
      font-weight:500;
    }
    .progressBar{
      height:8px;
      background:#e5e7eb;
      border-radius:999px;
      overflow:hidden;
    }
    .progressFill{
      height:100%;
      background:linear-gradient(90deg, #3b82f6, #6366f1);
      border-radius:999px;
      transition:width .3s ease;
      position:relative;
    }
    .progressFill::after{
      content:'';
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation:shimmer 1.5s infinite;
    }
    @keyframes shimmer{
      0%{transform:translateX(-100%);}
      100%{transform:translateX(100%);}
    }
    .miniProgress{
      display:none;
      width:80px;
      height:6px;
      background:#e5e7eb;
      border-radius:999px;
      overflow:hidden;
    }
    .miniProgress.active{
      display:block;
    }
    .miniProgressFill{
      height:100%;
      background:linear-gradient(90deg, #3b82f6, #6366f1);
      border-radius:999px;
      transition:width .3s ease;
      position:relative;
    }
    .miniProgressFill::after{
      content:'';
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      animation:shimmer 1.5s infinite;
    }
    [data-theme="dark"] .miniProgress{
      background:#334155;
    }
    pre{
      margin:10px 0 0 0;
      padding:12px;
      border-radius:18px;
      border:1px solid var(--border);
      background:var(--bg);
      font-size:12px;
      color:var(--text);
      white-space:pre-wrap;
      word-break:break-word;
      max-height:220px;
      overflow:auto;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      color:var(--muted);
    }
    .copyable{
      cursor:pointer;
      border-radius:4px;
      padding:1px 4px;
      margin:-1px -4px;
      transition:background .15s;
    }
    .copyable:hover{
      background:rgba(99,102,241,.1);
    }
    .toast{
      position:fixed;
      bottom:24px;
      left:50%;
      transform:translateX(-50%) translateY(100px);
      background:#1f2937;
      color:white;
      padding:12px 24px;
      border-radius:12px;
      font-size:14px;
      font-weight:500;
      box-shadow:0 4px 20px rgba(0,0,0,.2);
      z-index:10001;
      opacity:0;
      transition:transform .3s ease, opacity .3s ease;
    }
    .toast.show{
      transform:translateX(-50%) translateY(0);
      opacity:1;
    }

    .searchRow{
      display:flex;
      gap:8px;
      align-items:stretch;
    }
    .searchRow input{
      flex:1;
      min-width:0;
    }
    .sortBtn{
      display:flex;
      align-items:center;
      justify-content:center;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:0 16px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      color:var(--text);
      white-space:nowrap;
      transition:background .15s;
    }
    .sortBtn:hover{
      background:var(--hover);
    }

    /* List */
    .list{border-top:1px solid var(--border); margin-top:16px;}
    .row{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      cursor:pointer;
      background:var(--card);
      transition:background .15s ease;
    }
    .row:hover{background:#fafafa;}
    .row.selected{
      background:#eef2ff;
      border-left:3px solid #6366f1;
    }
    [data-theme="dark"] .row:hover{background:#1e293b;}
    [data-theme="dark"] .row.selected{
      background:#312e81;
      border-left:3px solid #818cf8;
    }
    .row:last-child{border-bottom:none;}
    .rowLeft{display:flex; align-items:flex-start; gap:12px; min-width:0;}
    .rowIcon{
      width:34px; height:34px; border-radius:12px;
      background:var(--bg);
      border:1px solid var(--border);
      display:grid; place-items:center;
      color:#6b7280;
      flex:0 0 auto;
      margin-top:2px;
    }
    .rowText{min-width:0;}
    .rowTitle{
      font-weight:800; font-size:13px; letter-spacing:-.2px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .rowSub{
      margin-top:4px;
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
    }
    .rowRight{text-align:right; min-width:34%; max-width:42%;}
    .rowValue{
      font-weight:700; font-size:13px; color:var(--text);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .rowValue.muted{color:var(--muted); font-weight:650;}
    .rowMeta{margin-top:6px; display:flex; justify-content:flex-end; gap:8px; align-items:center; flex-wrap:wrap;}
    .statusPill{
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      border:1px solid var(--border);
      background:var(--card);
      color:var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .statusPill.ok{border-color:#bbf7d0; background:#f0fdf4; color:#166534;}
    .statusPill.no{border-color:#fecaca; background:#fef2f2; color:#991b1b;}
    .statusPill.pending{border-color:var(--border); background:var(--card); color:var(--muted);}
    [data-theme="dark"] .statusPill.ok{border-color:#166534; background:#14532d; color:#bbf7d0;}
    [data-theme="dark"] .statusPill.no{border-color:#991b1b; background:#7f1d1d; color:#fecaca;}

    .chev{color:#9ca3af; margin-left:10px; flex:0 0 auto; margin-top:2px;}

    .list > .expanded{
      padding:0 16px 14px 62px;
      background:var(--card);
      border-bottom:1px solid var(--border);
    }
    .warn{margin-top:8px; color:#991b1b; font-size:12px; line-height:1.35;}
    [data-theme="dark"] .warn{color:#fca5a5;}
    .smallBtn{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:8px;
      padding:6px 12px;
      font-size:11px;
      font-weight:500;
      cursor:pointer;
      color:var(--text);
      transition:background .15s;
    }
    .smallBtn:hover{
      background:var(--hover);
    }

    /* Map popup */
    .ol-popup{
      position:absolute;
      background:var(--card);
      color:var(--text);
      padding:10px 14px;
      border-radius:10px;
      box-shadow:0 4px 20px rgba(0,0,0,0.15);
      border:1px solid var(--border);
      white-space:nowrap;
    }

    /* OpenLayers tweaks */
    .ol-control{
      background:transparent !important;
      box-shadow:none !important;
    }
    .ol-control button{
      width:34px !important;
      height:34px !important;
      border-radius:12px !important;
      border:1px solid var(--border) !important;
      box-shadow:none !important;
      background:var(--card) !important;
      color:var(--text) !important;
      font-size:18px !important;
      cursor:pointer !important;
    }
    .ol-control button:hover{
      background:var(--card) !important;
    }
    .ol-zoom{
      display:flex;
      flex-direction:column;
      gap:4px;
      background:transparent !important;
      box-shadow:none !important;
    }
    .ol-zoom button{
      margin:0 !important;
    }
    .ol-attribution{
      background:rgba(255,255,255,.9) !important;
      border:1px solid var(--border) !important;
      border-radius:14px !important;
      padding:6px 10px !important;
      box-shadow:none !important;
    }
    .ol-attribution ul{
      color:var(--muted) !important;
    }
    .ol-control.streetview-control{
      background:transparent !important;
      box-shadow:none !important;
    }
    .ol-control.streetview-control button{
      background:var(--card) !important;
      border:1px solid var(--border) !important;
      border-radius:12px !important;
      box-shadow:none !important;
    }
    .ol-control.streetview-control button:hover{
      background:var(--card) !important;
    }

    /* Desktop: drawer pinned by default but still closable */
    @media (min-width:1180px){
      .drawer.open{transform:translateX(0);}
      .overlay{display:none;}
      }

    /* Make cards scrollable inside drawer */
    .drawerBody{min-height:0;}
    .card{min-height:0;}

    /* Accordion cards */
    .card{
      display:flex;
      flex-direction:column;
      flex:0 0 auto;
    }

    .card.expanded .cardBody{
      max-height:none;
    }

    /* Firms card specific - make list scrollable */
    #firmsCard.expanded .cardBody{
      max-height:60vh;
      display:flex;
      flex-direction:column;
      overflow-y:auto;
      overflow-x:hidden;
    }
    #firmsCard.expanded .cardBody > *:not(#rows){
      flex:0 0 auto;
    }
    #rows{
      flex:1 1 auto;
      overflow:auto;
      min-height:0;
    }



    /* Map layout: fill width when menu closed; shift only when drawer open (desktop) */
    #map{ left:0 !important; right:0; transition:left .20s ease; }
    @media (min-width:1180px){
      body.drawer-open #map{ left:520px !important; }
    }

    /* Geocoding action row (moved from top-right) */
    .geoActionsRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .geoActionsRow .countChips{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    /* Toggle switch */
    .settingRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px 0;
      gap:20px;
      margin:0;
    }
    .settingRow > div{
      margin:0;
      padding:0;
    }
    .settingLabelRow{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .infoIcon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px;
      height:16px;
      border-radius:50%;
      background:var(--border);
      color:var(--muted);
      font-size:10px;
      font-weight:700;
      cursor:help;
      position:relative;
    }
    .infoIcon:hover .tooltip{
      display:block;
    }
    .tooltip{
      display:none;
      position:absolute;
      bottom:calc(100% + 8px);
      left:50%;
      transform:translateX(-50%);
      background:var(--text);
      color:var(--bg);
      padding:8px 12px;
      border-radius:8px;
      font-size:12px;
      font-weight:500;
      white-space:normal;
      width:200px;
      text-align:center;
      z-index:100;
      box-shadow:0 4px 12px rgba(0,0,0,0.15);
    }
    .tooltip::after{
      content:'';
      position:absolute;
      top:100%;
      left:50%;
      transform:translateX(-50%);
      border:6px solid transparent;
      border-top-color:var(--text);
    }
    .settingInput{
      width:46px;
      min-width:46px;
      max-width:46px;
      padding:8px 4px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--bg);
      color:var(--text);
      font-size:14px;
      font-weight:600;
      text-align:center;
      flex-shrink:0;
    }
    .settingInput:focus{
      outline:none;
      border-color:#c7d2fe;
      box-shadow:0 0 0 3px rgba(99,102,241,.12);
    }
    .settingRow:not(:last-child){
      border-bottom:1px solid var(--border);
    }
    .settingRow:first-child{
      padding-top:0;
    }
    .settingLabel{
      font-size:14px;
      font-weight:600;
      color:var(--text);
      margin:0;
      padding:0;
    }
    .settingDesc{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .toggle{
      position:relative;
      width:48px;
      height:26px;
      flex-shrink:0;
    }
    .toggle input{
      opacity:0;
      width:0;
      height:0;
    }
    .toggleSlider{
      position:absolute;
      cursor:pointer;
      top:0; left:0; right:0; bottom:0;
      background:#cbd5e1;
      border-radius:999px;
      transition:background .2s;
    }
    .toggleSlider::before{
      position:absolute;
      content:"";
      height:20px;
      width:20px;
      left:3px;
      bottom:3px;
      background:white;
      border-radius:999px;
      transition:transform .2s;
      box-shadow:0 2px 4px rgba(0,0,0,.15);
    }
    .toggle input:checked + .toggleSlider{
      background:#2563eb;
    }
    .toggle input:checked + .toggleSlider::before{
      transform:translateX(22px);
    }
    
    /* Street View Modal */
    .svModal{
      display:none;
      position:fixed;
      top:0;left:0;right:0;bottom:0;
      background:rgba(0,0,0,.7);
      z-index:10000;
      align-items:center;
      justify-content:center;
    }
    .svModal.open{display:flex;}
    .svModalContent{
      width:90%;
      max-width:1280px;
      aspect-ratio:16/9;
      max-height:85vh;
      background:var(--card);
      border-radius:16px;
      overflow:hidden;
      position:relative;
      box-shadow:0 20px 60px rgba(0,0,0,.3);
    }
    @media (max-width:768px){
      .svModalContent{
        width:95%;
        aspect-ratio:auto;
        height:60vh;
      }
    }
    .svModalClose{
      position:absolute;
      top:12px;right:12px;
      width:36px;height:36px;
      border-radius:50%;
      background:rgba(0,0,0,.6);
      color:white;
      border:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
      font-size:20px;
    }
    .svModalClose:hover{background:rgba(0,0,0,.8);}
    .svModalIframe{
      width:100%;
      height:100%;
      border:none;
    }
    </style>
</head>

<body>
  <div class="topbar">
    <div class="leftGroup">
      <button id="menuBtn" class="iconBtn" aria-label="Open menu" title="Menu">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 7h16M4 12h16M4 17h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>

      <div class="titleBlock">
        <div class="title">Japanese Venture Capital Firms</div>
      </div>
    </div>

    <div class="rightGroup">
    </div>
  </div>

  <div id="map"></div>

  <div id="mapError" style="display:none; position:fixed; top:64px; left:0; right:0; bottom:0; background:var(--bg); z-index:1; justify-content:center; align-items:center;">
    <div style="max-width:500px; background:var(--card); border:1px solid var(--border); border-radius:22px; padding:32px; box-shadow:0 12px 28px rgba(15,23,42,.08); text-align:center;">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" style="margin-bottom:16px; color:var(--muted);">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
        <path d="M12 8v4M12 16h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <h2 style="margin:0 0 12px 0; font-size:18px; font-weight:800;">Map Library Could Not Load</h2>
      <p style="margin:0 0 20px 0; color:var(--muted); font-size:14px; line-height:1.5;">
        This interactive map requires the OpenLayers library, which can't be loaded in this preview environment.
      </p>
      <p style="margin:0; color:var(--muted); font-size:14px; line-height:1.5;">
        <strong>To use the map:</strong> Download this file and open it directly in your browser.
      </p>
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

  <aside id="drawer" class="drawer" aria-label="Menu drawer">
    <div class="drawerHeader">
      <h2>Menu</h2>
      <button id="closeBtn" class="iconBtn" aria-label="Close menu" title="Close">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
    </div>

    <div class="drawerBody">
      <section class="card" id="settingsCard">
        <div class="cardHead">
          <span class="sectionTitle">Settings</span>
          <svg class="chevron" width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="cardBody">
          <div class="settingRow">
            <div>
              <div class="settingLabel">Dark Mode</div>
              <div class="settingDesc">Toggle dark theme</div>
            </div>
            <label class="toggle">
              <input type="checkbox" id="darkModeToggle">
              <span class="toggleSlider"></span>
            </label>
          </div>

          <div class="settingRow">
            <div>
              <div class="settingLabel">Cluster Pins</div>
              <div class="settingDesc">Group nearby pins on map</div>
            </div>
            <label class="toggle">
              <input type="checkbox" id="clusterToggle">
              <span class="toggleSlider"></span>
            </label>
          </div>

          <div class="settingRow">
            <div>
              <div class="settingLabel">Group Same Building</div>
              <div class="settingDesc">Combine firms at same address</div>
            </div>
            <label class="toggle">
              <input type="checkbox" id="sameBuildingToggle" checked>
              <span class="toggleSlider"></span>
            </label>
          </div>

          <div class="settingRow">
            <div>
              <div class="settingLabelRow">
                <span class="settingLabel">Parallel Requests</span>
                <span class="infoIcon">i<span class="tooltip">Number of geocoding requests to run simultaneously</span></span>
              </div>
              <div class="settingDesc">Batch size for geocoding</div>
            </div>
            <input type="number" id="batchSize" class="settingInput" min="1" max="50" value="10" />
          </div>
        </div>
      </section>

      <section class="card" id="geocodingCard">
        <div class="cardHead">
          <div style="display:flex; align-items:center; gap:12px; flex:1;">
            <span class="sectionTitle">Geocoding</span>
            <div id="miniProgress" class="miniProgress">
              <div id="miniProgressFill" class="miniProgressFill" style="width:0%"></div>
            </div>
          </div>
          <svg class="chevron" width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="cardBody">
          <div class="btnRow">
            <button id="importCSV" class="btn">Import CSV</button>
            <button id="downloadCSV" class="btn">Download CSV</button>
          </div>
          <input type="file" id="csvFileInput" accept=".csv" style="display:none;" />

          <div style="margin-top:18px;">
            <label for="geocodeProvider">Geocoding Provider</label>
            <select id="geocodeProvider" style="width:100%; padding:14px; border-radius:16px; border:1px solid var(--border); background:var(--bg); color:var(--text); outline:none; cursor:pointer;">
              <option value="nominatim">Nominatim (OpenStreetMap) - Free</option>
              <option value="mapbox">Mapbox - Best for Japan (API key required)</option>
            </select>
          </div>

          <div id="nominatimSettings">
            <div style="margin-top:12px;">
              <label for="endpoint">Nominatim endpoint</label>
              <input id="endpoint" type="text" value="https://nominatim.openstreetmap.org/search" />
            </div>
          </div>

          <div id="mapboxSettings" style="display:none;">
            <div style="margin-top:12px;">
              <label for="mapboxToken">Mapbox Access Token</label>
              <input id="mapboxToken" type="text" placeholder="pk.eyJ1Ijoi..." />
            </div>
            <div class="hint" style="margin-top:8px;">
              Get your free token at <a href="https://account.mapbox.com/access-tokens/" target="_blank" rel="noopener">mapbox.com</a> (100k free/month)
            </div>
          </div>

          <div style="margin-top:18px;">
            <label for="delay">Delay between batches (ms)</label>
            <input id="delay" type="number" min="50" step="50" value="100" />
          </div>

          <div class="btnRow">
            <button id="start" class="btn primary">Start / Restart</button>
            <button id="stop" class="btn">Stop</button>
          </div>

          <div id="progressContainer" class="progressContainer">
            <div class="progressLabel">
              <span>Geocoding in progress...</span>
              <span id="progressStatus" class="status">0 / 0</span>
            </div>
            <div class="progressBar">
              <div id="progressFill" class="progressFill" style="width:0%"></div>
            </div>
          </div>

          <div class="btnRow">
            <button id="test" class="btn">Run Test</button>
            <button id="clearCache" class="btn danger">Clear Cache</button>
          </div>

          <div class="hint">
            If you see lots of failures, click a firm to expand and inspect <span class="mono">HTTP status</span> + the last URL.
            <br/><span class="mono">HTTP 429</span> → rate limit (increase delay). <span class="mono">HTTP 403</span> or HTML → blocked (try different network / remove VPN / use another geocoder).
          </div>

          <pre id="testOut">Test output will appear here.</pre>
        </div>
      </section>

      <section class="card" id="firmsCard">
        <div class="cardHead" style="gap:12px;">
          <div style="display:flex; align-items:center; gap:12px; flex:1;">
            <span class="sectionTitle">Firms</span>
            <div class="countChips">
              <div class="chip"><span class="dot ok"></span><span id="okCount">0</span></div>
              <div class="chip"><span class="dot no"></span><span id="noCount">0</span></div>
              <div class="chip"><span class="dot pending"></span><span id="pendingCount">0</span></div>
            </div>
          </div>
          <svg class="chevron" width="20" height="20" viewBox="0 0 24 24" fill="none">
            <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="cardBody" style="padding-bottom:12px;">
          <label for="filter">Search</label>
          <div class="searchRow">
            <input id="filter" type="text" placeholder="Search firms..." />
            <button id="sortToggle" class="sortBtn" title="Toggle sort order">
              <span id="sortIcon">A-Z</span>
            </button>
          </div>

          <div id="rows" class="list"></div>
        </div>
      </section>
    </div>
  </aside>

  <!-- Street View Modal -->
  <div id="svModal" class="svModal">
    <div class="svModalContent">
      <button id="svModalClose" class="svModalClose">✕</button>
      <iframe id="svModalIframe" class="svModalIframe" allow="accelerometer; gyroscope;"></iframe>
    </div>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast"></div>

  <script>
    // Global error handler
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      console.error('Script Error:', msg, '\nURL:', url, '\nLine:', lineNo, '\nColumn:', columnNo, '\nError:', error);
      return false;
    };
  </script>

  <script src="https://cdn.jsdelivr.net/npm/ol@v8.2.0/dist/ol.js" onerror="console.error('Failed to load OpenLayers library from CDN. Check internet connection.')"></script>

  <script>
    const FIRMS = [
      {"name":"Globis Capital Partners","address":"9F Sumitomo Fudosan Kojimachi Bldg., 5-1 Niban-cho, Chiyoda-ku, Tokyo 102-0084, Japan","website":""},
      {"name":"CyberAgent Ventures (CyberAgent Capital)","address":"5F Abema Towers, 40-1 Udagawacho, Shibuya-ku, Tokyo 150-0042, Japan","website":""},
      {"name":"Strive (GREE Ventures)","address":"Holland Hills Mori Tower RoP #1203, 5-11-1 Toranomon, Minato-ku, Tokyo 105-0001, Japan","website":""},
      {"name":"Rebright Partners","address":"2F Nittochi Building, 1-4-1 Kasumigaseki, Chiyoda-ku, Tokyo 100-0013, Japan","website":""},
      {"name":"Drone Fund","address":"Azabudai Hills Garden Plaza B 4F, 5-9-1 Toranomon, Minato-ku, Tokyo 105-0001, Japan","website":""},
      {"name":"Incubate Fund","address":"Azabudai Hills Garden Plaza B 5F, 5-9-1 Toranomon, Minato-ku, Tokyo 105-0001, Japan","website":""},
      {"name":"ITOCHU Technology Ventures (ITV)","address":"Itochu Building 4F, 2-5-1 Kita-Aoyama, Minato-ku, Tokyo 107-0061, Japan","website":""},
      {"name":"DG Incubation (Digital Garage)","address":"Digital Gate Building, 3-5-7 Ebisu Minami, Shibuya-ku, Tokyo 150-0022, Japan","website":""},
      {"name":"Mistletoe","address":"1-1 Kanda-Awajicho, Chiyoda-ku, Tokyo 101-0063, Japan","website":""},
      {"name":"Monex Ventures","address":"ARK Mori Building 25F, 1-12-32 Akasaka, Minato-ku, Tokyo 107-6025, Japan","website":""},
      {"name":"Mitsubishi UFJ Capital","address":"Nihonbashi Plaza Building 7F, 2-3-4 Nihonbashi, Chuo-ku, Tokyo 103-0027, Japan","website":""},
      {"name":"Rakuten Ventures","address":"Rakuten Crimson House, 1-14-1 Tamagawa, Setagaya-ku, Tokyo 158-0094, Japan","website":""},
      {"name":"SBI Investment","address":"Izumi Garden Tower 19F, 1-6-1 Roppongi, Minato-ku, Tokyo 106-6019, Japan","website":""},
      {"name":"JAFCO Group","address":"Toranomon Hills Mori Tower 24F, 1-23-1 Toranomon, Minato-ku, Tokyo 105-6324, Japan","website":""},
      {"name":"Spiral Ventures (Spiral Capital)","address":"Azabudai Hills Garden Plaza B 504, 5-9-1 Toranomon, Minato-ku, Tokyo 105-0001, Japan","website":""},
      {"name":"Abies Ventures","address":"Landwork Aoyama Building 2F, 2-7-26 Kita-Aoyama, Minato-ku, Tokyo 107-0061, Japan","website":""},
      {"name":"ANRI","address":"Roppongi Hills Mori Tower 15F, 6-10-1 Roppongi, Minato-ku, Tokyo 106-6115, Japan","website":""},
      {"name":"UTEC (University of Tokyo Edge Capital Partners)","address":"South Clinical Research Bldg. 3F, 7-3-1 Hongo, Bunkyo-ku, Tokyo 113-8485, Japan","website":""},
      {"name":"Beyond Next Ventures","address":"MFPR Nihonbashi Honcho Building 3F, 3-7-2 Nihonbashi-Honcho, Chuo-ku, Tokyo 103-0023, Japan","website":""},
      {"name":"Leave a Nest Capital","address":"Iidabashi Miyuki Building 5F, 1-4 Shimomiyabi-cho, Shinjuku-ku, Tokyo 162-0822, Japan","website":""}
    ];

    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('overlay');
    const menuBtn = document.getElementById('menuBtn');
    const closeBtn = document.getElementById('closeBtn');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const clusterToggle = document.getElementById('clusterToggle');
    const sameBuildingToggle = document.getElementById('sameBuildingToggle');

    function openDrawer(){
      drawer.classList.add('open');
      overlay.classList.add('open');
      document.body.classList.add('drawer-open');
    }
    function closeDrawer(){
      drawer.classList.remove('open');
      overlay.classList.remove('open');
      document.body.classList.remove('drawer-open');
    }
    function toggleDrawer(){
      if(drawer.classList.contains('open')) closeDrawer();
      else openDrawer();
    }
    menuBtn.addEventListener('click', toggleDrawer);
    closeBtn.addEventListener('click', closeDrawer);
    overlay.addEventListener('click', closeDrawer);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDrawer(); });

    // Accordion behavior for cards
    const allCards = document.querySelectorAll('.card');

    // Ensure all cards start collapsed
    allCards.forEach(c => c.classList.remove('expanded'));

    allCards.forEach(card => {
      const cardHead = card.querySelector('.cardHead');
      if(cardHead){
        cardHead.addEventListener('click', (e) => {
          // Prevent toggle switch clicks from triggering accordion
          if(e.target.closest('.toggle')) return;

          const isExpanded = card.classList.contains('expanded');

          // Collapse all cards
          allCards.forEach(c => c.classList.remove('expanded'));

          // Toggle clicked card (expand if it was collapsed)
          if(!isExpanded){
            card.classList.add('expanded');
          }
        });
      }
    });

    // Settings persistence
    const SETTINGS_KEY = "jvc_map_settings";
    function loadSettings(){
      try {
        const defaults = {darkMode:false, clustering:false, sameBuilding:true, geocodeProvider:'nominatim', mapboxToken:''};
        const saved = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
        return {...defaults, ...saved};
      } catch {
        return {darkMode:false, clustering:false, sameBuilding:true, geocodeProvider:'nominatim', mapboxToken:''};
      }
    }
    function saveSettings(settings){
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }

    // Dark mode toggle
    let setMapDarkMode = null; // Will be set when map is initialized
    
    function setDarkMode(enabled){
      if(enabled){
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.removeAttribute('data-theme');
      }
      const settings = loadSettings();
      settings.darkMode = enabled;
      saveSettings(settings);
      
      // Update map tiles if map is initialized
      if(setMapDarkMode) setMapDarkMode(enabled);
      
      // Refresh pin labels for new color scheme
      if(vectorSource){
        vectorSource.changed();
      }
      if(clusterSource){
        clusterSource.changed();
      }
    }

    darkModeToggle.addEventListener('change', (e)=>{
      setDarkMode(e.target.checked);
    });

    // Initialize OpenLayers variables (declared early so setDarkMode can reference them)
    let vectorSource, clusterSource, vectorLayer, clusterLayer, map, popup, popupContainer;

    // Load saved settings
    const savedSettings = loadSettings();
    darkModeToggle.checked = savedSettings.darkMode;
    setDarkMode(savedSettings.darkMode);
    clusterToggle.checked = savedSettings.clustering;
    sameBuildingToggle.checked = savedSettings.sameBuilding;
    let sameBuildingEnabled = savedSettings.sameBuilding;

    // Start with menu open by default
    openDrawer();

    // Check if OpenLayers loaded
    if (typeof ol === 'undefined') {
      document.getElementById('map').style.display = 'none';
      document.getElementById('mapError').style.display = 'flex';
      // Continue with non-map functionality (drawer, render, etc.)
    }

    // Initialize OpenLayers map (only if library loaded)
    
    if (typeof ol !== 'undefined') {
      vectorSource = new ol.source.Vector();
      clusterSource = new ol.source.Cluster({
        distance: 40,
        source: vectorSource
      });

    const styleCache = {};

    // Create pin style with label
    function createPinStyle(name, isSelected){
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#f1f5f9' : '#1f2937';
      const bgColor = isDark ? 'rgba(30, 41, 59, 1)' : 'rgba(255, 255, 255, 1)';
      
      return new ol.style.Style({
        image: new ol.style.Circle({
          radius: isSelected ? 12 : 8,
          fill: new ol.style.Fill({ color: isSelected ? '#dc2626' : '#2563eb' }),
          stroke: new ol.style.Stroke({ color: 'white', width: isSelected ? 3 : 2 })
        }),
        text: new ol.style.Text({
          text: name || '',
          font: isSelected ? 'bold 14px sans-serif' : '13px sans-serif',
          offsetY: isSelected ? -18 : -14,
          textBaseline: 'bottom',
          fill: new ol.style.Fill({ color: textColor }),
          stroke: new ol.style.Stroke({ color: bgColor, width: 5 }),
          padding: [2, 4, 2, 4]
        }),
        zIndex: isSelected ? 1000 : 1
      });
    }
    
    // Create grouped pin style with count badge
    function createGroupPinStyle(names, count, isSelected){
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#f1f5f9' : '#1f2937';
      const bgColor = isDark ? 'rgba(30, 41, 59, 1)' : 'rgba(255, 255, 255, 1)';
      
      return [
        new ol.style.Style({
          image: new ol.style.Circle({
            radius: isSelected ? 16 : 12,
            fill: new ol.style.Fill({ color: isSelected ? '#dc2626' : 'rgba(37, 99, 235, 0.9)' }),
            stroke: new ol.style.Stroke({ color: 'white', width: isSelected ? 3 : 2 })
          }),
          text: new ol.style.Text({
            text: count.toString(),
            font: 'bold 11px sans-serif',
            fill: new ol.style.Fill({ color: 'white' })
          }),
          zIndex: isSelected ? 1000 : 1
        }),
        new ol.style.Style({
          text: new ol.style.Text({
            text: names || '',
            font: isSelected ? 'bold 14px sans-serif' : '13px sans-serif',
            offsetY: isSelected ? -22 : -18,
            textBaseline: 'bottom',
            fill: new ol.style.Fill({ color: textColor }),
            stroke: new ol.style.Stroke({ color: bgColor, width: 5 }),
            padding: [2, 4, 2, 4]
          }),
          zIndex: isSelected ? 1001 : 2
        })
      ];
    }

    // Style function for vector layer
    function pinStyleFunction(feature){
      const name = feature.get('name') || '';
      const isSelected = feature.get('selected');
      const isGroup = feature.get('isGroup');
      const groupCount = feature.get('groupCount') || 1;
      
      if(isGroup && groupCount > 1){
        return createGroupPinStyle(name, groupCount, isSelected);
      }
      return createPinStyle(name, isSelected);
    }

    // Cluster style function
    function clusterStyleFunction(feature) {
      const features = feature.get('features');
      const size = features.length;
      
      // Check if any feature in cluster is selected
      const hasSelected = features.some(f => f.get('selected'));
      
      if(size === 1){
        const f = features[0];
        const name = f.get('name') || '';
        const isGroup = f.get('isGroup');
        const groupCount = f.get('groupCount') || 1;
        
        if(isGroup && groupCount > 1){
          return createGroupPinStyle(name, groupCount, hasSelected);
        }
        return createPinStyle(name, hasSelected);
      }
      
      // For clusters of multiple pins, calculate total firms
      let totalFirms = 0;
      let allNames = [];
      for(const f of features){
        const count = f.get('groupCount') || 1;
        totalFirms += count;
        const name = f.get('name') || '';
        if(name) allNames.push(...name.split('\n'));
      }
      allNames.sort();
      
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#f1f5f9' : '#1f2937';
      const bgColor = isDark ? 'rgba(30, 41, 59, 1)' : 'rgba(255, 255, 255, 1)';
      
      return [
        new ol.style.Style({
          image: new ol.style.Circle({
            radius: 15 + Math.min(totalFirms / 2, 15),
            fill: new ol.style.Fill({ color: 'rgba(37, 99, 235, 0.8)' }),
            stroke: new ol.style.Stroke({ color: 'white', width: 2 })
          }),
          text: new ol.style.Text({
            text: totalFirms.toString(),
            fill: new ol.style.Fill({ color: 'white' }),
            font: 'bold 12px sans-serif'
          }),
          zIndex: 1
        }),
        new ol.style.Style({
          text: new ol.style.Text({
            text: allNames.join('\n'),
            font: '13px sans-serif',
            offsetY: -(15 + Math.min(totalFirms / 2, 15)),
            textBaseline: 'bottom',
            fill: new ol.style.Fill({ color: textColor }),
            stroke: new ol.style.Stroke({ color: bgColor, width: 5 }),
            padding: [2, 4, 2, 4]
          }),
          zIndex: 2
        })
      ];
    }

    const vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      style: pinStyleFunction,
      renderOrder: function(a, b) {
        // Selected features should render on top
        const aSelected = a.get('selected') ? 1 : 0;
        const bSelected = b.get('selected') ? 1 : 0;
        return aSelected - bSelected;
      }
    });

    const clusterLayer = new ol.layer.Vector({
      source: clusterSource,
      style: clusterStyleFunction,
      renderOrder: function(a, b) {
        // Check if any feature in cluster is selected
        const aFeatures = a.get('features') || [];
        const bFeatures = b.get('features') || [];
        const aSelected = aFeatures.some(f => f.get('selected')) ? 1 : 0;
        const bSelected = bFeatures.some(f => f.get('selected')) ? 1 : 0;
        return aSelected - bSelected;
      }
    });

    // Tile sources for light/dark mode
    const lightTileSource = new ol.source.OSM();
    const darkTileSource = new ol.source.XYZ({
      url: 'https://{a-c}.basemaps.cartocdn.com/rastertiles/dark_all/{z}/{x}/{y}{r}.png',
      attributions: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    });

    const tileLayer = new ol.layer.Tile({
      source: savedSettings.darkMode ? darkTileSource : lightTileSource
    });

    const map = new ol.Map({
      target: 'map',
      layers: [tileLayer],
      view: new ol.View({
        center: ol.proj.fromLonLat([139.6503, 35.6762]),
        zoom: 11
      })
    });

    // Street View control
    let streetViewMode = false;
    const streetViewBtn = document.createElement('button');
    streetViewBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24">
      <circle cx="12" cy="5" r="3.5" fill="#FBBC04"/>
      <path d="M12 9c-2.5 0-4.5 1.5-4.5 4v5.5c0 .8.7 1.5 1.5 1.5s1.5-.7 1.5-1.5V15h3v3.5c0 .8.7 1.5 1.5 1.5s1.5-.7 1.5-1.5V13c0-2.5-2-4-4.5-4z" fill="#FBBC04"/>
      <circle cx="10.5" cy="4.5" r="0.8" fill="#4a4a4a"/>
      <circle cx="13.5" cy="4.5" r="0.8" fill="#4a4a4a"/>
    </svg>`;
    streetViewBtn.title = 'Street View - Click to enable, then click on map';
    streetViewBtn.style.cssText = 'width:34px;height:34px;display:flex;align-items:center;justify-content:center;cursor:pointer;';
    
    const streetViewControl = new ol.control.Control({
      element: (function(){
        const div = document.createElement('div');
        div.className = 'ol-control ol-unselectable streetview-control';
        div.style.cssText = 'top:90px;left:.5em;';
        div.appendChild(streetViewBtn);
        return div;
      })()
    });
    map.addControl(streetViewControl);

    streetViewBtn.addEventListener('click', ()=>{
      streetViewMode = !streetViewMode;
      streetViewBtn.style.boxShadow = streetViewMode ? '0 0 0 3px #FBBC04' : '';
      map.getTargetElement().style.cursor = streetViewMode ? 'crosshair' : '';
    });

    setMapDarkMode = function(isDark){
      tileLayer.setSource(isDark ? darkTileSource : lightTileSource);
    };

    // Clustering toggle
    let clusteringEnabled = savedSettings.clustering;
    function setClustering(enabled){
      map.getLayers().clear();
      map.addLayer(tileLayer);

      if(enabled){
        map.addLayer(clusterLayer);
      } else {
        map.addLayer(vectorLayer);
      }

      clusteringEnabled = enabled;
      const settings = loadSettings();
      settings.clustering = enabled;
      saveSettings(settings);
    }

    clusterToggle.addEventListener('change', (e)=>{
      setClustering(e.target.checked);
    });

    // Same Building toggle
    sameBuildingToggle.addEventListener('change', (e)=>{
      sameBuildingEnabled = e.target.checked;
      const settings = loadSettings();
      settings.sameBuilding = sameBuildingEnabled;
      saveSettings(settings);
      rebuildAllMarkers();
    });

    // Initialize with saved clustering preference
    setClustering(clusteringEnabled);

    // Popup overlay
    popupContainer = document.createElement('div');
    popupContainer.className = 'ol-popup';
    document.body.appendChild(popupContainer);

    popup = new ol.Overlay({
      element: popupContainer,
      positioning: 'bottom-center',
      stopEvent: false,
      offset: [0, -10]
    });
    map.addOverlay(popup);

    // Click handler for popup
    map.on('click', function(evt) {
      // Handle Street View mode
      if(streetViewMode){
        const coords = ol.proj.toLonLat(evt.coordinate);
        const lat = coords[1];
        const lon = coords[0];
        
        // Open Street View in modal
        const svModal = document.getElementById('svModal');
        const svIframe = document.getElementById('svModalIframe');
        svIframe.src = `https://maps.google.com/maps?q=${lat},${lon}&z=17&layer=c&cbll=${lat},${lon}&cbp=12,0,0,0,0&output=svembed`;
        svModal.classList.add('open');
        
        streetViewMode = false;
        streetViewBtn.style.boxShadow = '';
        map.getTargetElement().style.cursor = '';
        return;
      }

      const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
        return feature;
      });

      if (feature) {
        const features = feature.get('features');
        
        // Handle clustered features
        if (features && features.length === 1) {
          const props = features[0].getProperties();
          const firmIds = props.firmIds || (props.firmId ? [props.firmId] : []);
          
          // Select the first firm and expand all firms in the group
          if(firmIds.length > 0){
            selectFirm(firmIds[0]);
            
            // Expand all firms in the group
            for(const fid of firmIds){
              const firm = state.find(x => x.id === fid);
              if(firm) firm._expanded = true;
            }
            
            // Expand the Firms card
            const firmsCard = document.getElementById('firmsCard');
            if(firmsCard && !firmsCard.classList.contains('expanded')){
              document.querySelectorAll('.card').forEach(c => c.classList.remove('expanded'));
              firmsCard.classList.add('expanded');
            }
            
            render();
            
            // Scroll to the first row after a small delay
            setTimeout(() => {
              const rowEl = document.getElementById(firmIds[0]);
              if(rowEl){
                rowEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }
            }, 100);
          }
        } else if (features && features.length > 1) {
          // Multiple features in cluster - zoom in
          popup.setPosition(undefined);
          const extent = ol.extent.createEmpty();
          features.forEach(f => ol.extent.extend(extent, f.getGeometry().getExtent()));
          map.getView().fit(extent, { padding: [50, 50, 50, 50], duration: 500, maxZoom: 15 });
        } else if (!features) {
          // Non-clustered single feature (or grouped pin)
          const props = feature.getProperties();
          const firmIds = props.firmIds || (props.firmId ? [props.firmId] : []);
          
          if(firmIds.length > 0){
            selectFirm(firmIds[0]);
            
            // Expand all firms in the group
            for(const fid of firmIds){
              const firm = state.find(x => x.id === fid);
              if(firm) firm._expanded = true;
            }
            
            // Expand the Firms card
            const firmsCard = document.getElementById('firmsCard');
            if(firmsCard && !firmsCard.classList.contains('expanded')){
              document.querySelectorAll('.card').forEach(c => c.classList.remove('expanded'));
              firmsCard.classList.add('expanded');
            }
            
            render();
            
            // Scroll to the first row after a small delay
            setTimeout(() => {
              const rowEl = document.getElementById(firmIds[0]);
              if(rowEl){
                rowEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
              }
            }, 100);
          }
        }
      } else {
        popup.setPosition(undefined);
        // Deselect current firm
        if(selectedFirmId){
          const prevFirm = state.find(x => x.id === selectedFirmId);
          if(prevFirm) prevFirm._expanded = false;
          selectFirm(null);
          render();
        }
      }
    });

    // Change cursor on hover
    map.on('pointermove', function(evt) {
      if(streetViewMode) return; // Keep crosshair cursor in Street View mode
      const hit = map.hasFeatureAtPixel(evt.pixel);
      map.getTargetElement().style.cursor = hit ? 'pointer' : '';
    });
    } // End of OpenLayers initialization block

    const elRows = document.getElementById('rows');
    const elFilter = document.getElementById('filter');
    const elImportCSV = document.getElementById('importCSV');
    const elDownloadCSV = document.getElementById('downloadCSV');
    const elCsvFileInput = document.getElementById('csvFileInput');
    const elEndpoint = document.getElementById('endpoint');
    const elDelay = document.getElementById('delay');
    const elBatchSize = document.getElementById('batchSize');
    const elStart = document.getElementById('start');
    const elStop = document.getElementById('stop');
    const elClearCache = document.getElementById('clearCache');
    const elTest = document.getElementById('test');
    const elTestOut = document.getElementById('testOut');
    const elProgressContainer = document.getElementById('progressContainer');
    const elProgressStatus = document.getElementById('progressStatus');
    const elProgressFill = document.getElementById('progressFill');
    const elMiniProgress = document.getElementById('miniProgress');
    const elMiniProgressFill = document.getElementById('miniProgressFill');
    const elGeocodeProvider = document.getElementById('geocodeProvider');
    const elMapboxToken = document.getElementById('mapboxToken');
    const elNominatimSettings = document.getElementById('nominatimSettings');
    const elMapboxSettings = document.getElementById('mapboxSettings');

    // Provider toggle
    elGeocodeProvider.addEventListener('change', () => {
      const isMapbox = elGeocodeProvider.value === 'mapbox';
      elNominatimSettings.style.display = isMapbox ? 'none' : 'block';
      elMapboxSettings.style.display = isMapbox ? 'block' : 'none';
      // Save preference
      const settings = loadSettings();
      settings.geocodeProvider = elGeocodeProvider.value;
      saveSettings(settings);
    });

    // Save Mapbox token on change
    elMapboxToken.addEventListener('change', () => {
      const settings = loadSettings();
      settings.mapboxToken = elMapboxToken.value;
      saveSettings(settings);
    });

    // Load saved geocode provider settings
    (function initGeocodeSettings(){
      const settings = loadSettings();
      elGeocodeProvider.value = settings.geocodeProvider || 'nominatim';
      elMapboxToken.value = settings.mapboxToken || '';
      const isMapbox = settings.geocodeProvider === 'mapbox';
      elNominatimSettings.style.display = isMapbox ? 'none' : 'block';
      elMapboxSettings.style.display = isMapbox ? 'block' : 'none';
    })();

    const CACHE_KEY = "jvc_geocode_cache_captured_style_v1";
    function loadCache(){ try { return JSON.parse(localStorage.getItem(CACHE_KEY) || "{}"); } catch { return {}; } }
    function saveCache(cache){ localStorage.setItem(CACHE_KEY, JSON.stringify(cache)); }
    function clearCache(){ localStorage.removeItem(CACHE_KEY); }
    function cacheKeyFor(item){ return (item.name + "||" + item.address).toLowerCase(); }

    const state = FIRMS.map((f, idx) => ({
      ...f,
      id: `firm-${idx}`,
      status: 'pending',
      lat: null,
      lon: null,
      resolved: '',
      error: '',
      lastQuery: '',
      lastStatus: '',
      _expanded: false,
      _selected: false
    }));

    let sortBy = 'name'; // 'name' or 'address'
    
    function sortState(){
      state.sort((a, b) => {
        if(sortBy === 'name'){
          return a.name.localeCompare(b.name);
        } else {
          return a.address.localeCompare(b.address);
        }
      });
    }
    
    sortState(); // Initial sort

    let selectedFirmId = null;

    function selectFirm(firmId){
      selectedFirmId = firmId;
      state.forEach(x => x._selected = (x.id === firmId));
      
      // Highlight marker on map
      if(typeof ol !== 'undefined' && vectorSource){
        vectorSource.getFeatures().forEach(f => {
          const firmIds = f.get('firmIds');
          if(firmIds){
            // Grouped pin - check if firmId is in the group
            f.set('selected', firmIds.includes(firmId));
          } else {
            // Single pin
            f.set('selected', f.get('firmId') === firmId);
          }
        });
        vectorSource.changed();
        if(clusterSource) clusterSource.changed();
      }
    }

    function updateCounts(){
      document.getElementById('okCount').textContent = state.filter(x=>x.status==='ok').length;
      document.getElementById('noCount').textContent = state.filter(x=>x.status==='no').length;
      document.getElementById('pendingCount').textContent = state.filter(x=>x.status==='pending' || x.status==='queued').length;
    }

    function escapeHtml(s){
      return String(s||'')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#39;");
    }

    const toastEl = document.getElementById('toast');
    let toastTimeout;
    function showToast(msg){
      clearTimeout(toastTimeout);
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      toastTimeout = setTimeout(() => {
        toastEl.classList.remove('show');
      }, 2000);
    }

    function firmIconSvg(){
      return `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 21V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          <path d="M10 21V9a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          <path d="M8 7h4M8 11h4M8 15h4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>`;
    }

    function statusPill(status){
      if(status==='ok') return '<span class="statusPill ok"><span class="dot ok"></span>Geocoded</span>';
      if(status==='no') return '<span class="statusPill no"><span class="dot no"></span>Not found</span>';
      if(status==='queued') return '<span class="statusPill pending"><span class="dot pending"></span>Pending</span>';
      return '';
    }

    function render(){
      const q = (elFilter.value||'').toLowerCase().trim();
      elRows.innerHTML = '';

      const filtered = state.filter(x =>
        !q ||
        x.name.toLowerCase().includes(q) ||
        (x.address||'').toLowerCase().includes(q) ||
        (x.resolved||'').toLowerCase().includes(q)
      );

      for(const x of filtered){
        const row = document.createElement('div');
        row.className = 'row' + (x._selected ? ' selected' : '');
        row.id = x.id;

        const displayResolved = x.resolved
          ? x.resolved
          : (x.status==='no' ? 'Not found (click to expand)' : (x.status==='queued' ? 'Processing...' : '—'));

        row.innerHTML = `
          <div class="rowLeft">
            <div class="rowIcon">${firmIconSvg()}</div>
            <div class="rowText">
              <div class="rowTitle">${escapeHtml(x.name)}</div>
              <div class="rowSub">${escapeHtml(x.address)}</div>
            </div>
          </div>
          <div class="rowRight">
            <div class="rowValue ${x.status==='pending' ? 'muted' : ''}">${escapeHtml(displayResolved)}</div>
            <div class="rowMeta">
              ${statusPill(x.status)}
            </div>
          </div>
          <div class="chev">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9 18l6-6-6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        `;

        row.addEventListener('click', ()=>{ 
          x._expanded = !x._expanded; 
          selectFirm(x.id);
          
          // Pan map to firm if it has coordinates
          if(x.lat && x.lon && typeof ol !== 'undefined' && map){
            const coord = ol.proj.fromLonLat([x.lon, x.lat]);
            map.getView().animate({center: coord, duration: 300});
          }
          
          render(); 
        });
        elRows.appendChild(row);

        if(x._expanded){
          const exp = document.createElement('div');
          exp.className = 'expanded';
          const name = `<div class="mono" style="margin-top:10px;"><b>Name:</b> <span class="copyable" data-copy="${escapeHtml(x.name)}">${escapeHtml(x.name)}</span></div>`;
          const inputAddr = `<div class="mono" style="margin-top:6px;"><b>Input Address:</b> <span class="copyable" data-copy="${escapeHtml(x.address)}">${escapeHtml(x.address)}</span></div>`;
          const resolvedAddr = `<div class="mono" style="margin-top:6px;"><b>Resolved Address:</b> ${x.resolved ? `<span class="copyable" data-copy="${escapeHtml(x.resolved)}">${escapeHtml(x.resolved)}</span>` : '<span style="color:var(--muted);">—</span>'}</div>`;
          const coordsText = (x.lat && x.lon) ? `${x.lat.toFixed(6)}, ${x.lon.toFixed(6)}` : '';
          const coords = `<div class="mono" style="margin-top:6px;"><b>Coordinates:</b> ${coordsText ? `<span class="copyable" data-copy="${coordsText}">${coordsText}</span>` : '<span style="color:var(--muted);">—</span>'}</div>`;
          const query = `<div class="mono" style="margin-top:6px;"><b>Query:</b> ${x.lastQuery ? `<a target="_blank" rel="noopener" href="${escapeHtml(x.lastQuery)}">Link</a>` : '<span style="color:var(--muted);">—</span>'}</div>`;
          
          // Google Maps link - search by address or show coordinates
          const gmapsUrl = (x.lat && x.lon) 
            ? `https://www.google.com/maps?q=${x.lat},${x.lon}`
            : `https://www.google.com/maps/search/${encodeURIComponent(x.address)}`;
          const gmapsLink = `<div class="mono" style="margin-top:6px;"><b>Google Maps:</b> <a target="_blank" rel="noopener" href="${gmapsUrl}">Open</a></div>`;
          
          const warn = x.error ? `<div class="warn">⚠ ${escapeHtml(x.error)}</div>` : '';
          
          // Action buttons
          const actions = `<div class="expandedActions" style="margin-top:12px; display:flex; gap:8px;">
            <button class="editCoordsBtn smallBtn">Edit Coordinates</button>
          </div>`;
          
          exp.innerHTML = `
            ${name}
            ${inputAddr}
            ${resolvedAddr}
            ${coords}
            ${query}
            ${gmapsLink}
            ${warn}
            ${actions}
          `;
          
          // Add click handlers for copyable text
          exp.querySelectorAll('.copyable').forEach(el => {
            el.addEventListener('click', (e) => {
              e.stopPropagation();
              const text = el.getAttribute('data-copy');
              navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard');
              });
            });
          });
          
          // Edit coordinates button
          exp.querySelector('.editCoordsBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const currentCoords = (x.lat && x.lon) ? `${x.lat}, ${x.lon}` : '';
            const input = prompt('Enter coordinates (lat, lon):\n\nYou can copy these from Google Maps by right-clicking on the map.', currentCoords);
            if(input !== null && input.trim()){
              const parts = input.split(',').map(s => parseFloat(s.trim()));
              if(parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])){
                x.lat = parts[0];
                x.lon = parts[1];
                x.status = 'ok';
                x.error = '';
                x.resolved = x.resolved || '(manually set)';
                
                // Update cache
                const cache = loadCache();
                cache[cacheKeyFor(x)] = {
                  lat: x.lat,
                  lon: x.lon,
                  resolved: x.resolved,
                  lastStatus: 'Manual',
                  lastQuery: x.lastQuery
                };
                saveCache(cache);
                
                // Rebuild markers and re-render
                rebuildAllMarkers();
                render();
                showToast('Coordinates updated');
              } else {
                showToast('Invalid format. Use: lat, lon');
              }
            }
          });
          
          elRows.appendChild(exp);
        }
      }

      updateCounts();
    }
    elFilter.addEventListener('input', render);

    const sortToggle = document.getElementById('sortToggle');
    const sortIcon = document.getElementById('sortIcon');
    sortToggle.addEventListener('click', () => {
      sortBy = sortBy === 'name' ? 'address' : 'name';
      sortIcon.textContent = sortBy === 'name' ? 'A-Z' : '📍';
      sortToggle.title = sortBy === 'name' ? 'Sorted by name' : 'Sorted by address';
      sortState();
      render();
    });

    function toCSV(rows){
      const header = ['name','input_address','resolved_address','latitude','longitude','website','last_status','last_query','error'];
      const lines = [header.join(',')];
      for(const r of rows){
        const vals = [r.name, r.address, r.resolved||'', r.lat ?? '', r.lon ?? '', r.website||'', r.lastStatus||'', r.lastQuery||'', r.error||'']
          .map(v => '"' + String(v).replaceAll('"','""') + '"');
        lines.push(vals.join(','));
      }
      return lines.join('\n');
    }

    function downloadText(filename, text, mime){
      const blob = new Blob([text], {type:mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    elDownloadCSV.addEventListener('click', ()=> {
      const header = ['name','address','website'];
      const outLines = [header.join(',')];
      for(const r of state){
        const vals = [r.name, r.address, r.website||''].map(v => '"' + String(v).replaceAll('"','""') + '"');
        outLines.push(vals.join(','));
      }
      downloadText('japanese_vc_firms.csv', outLines.join('\n'), 'text/csv;charset=utf-8;');
    });

    elImportCSV.addEventListener('click', ()=> {
      elCsvFileInput.click();
    });

    elCsvFileInput.addEventListener('change', (e)=> {
      const file = e.target.files[0];
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = (evt)=> {
        const text = evt.target.result;
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        if(lines.length < 2) {
          alert('CSV file appears empty or has no data rows.');
          return;
        }
        
        // Parse header
        const header = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());
        const nameIdx = header.findIndex(h => h === 'name');
        const addressIdx = header.findIndex(h => h === 'address');
        const websiteIdx = header.findIndex(h => h === 'website');
        
        if(nameIdx === -1 || addressIdx === -1) {
          alert('CSV must have "name" and "address" columns.');
          return;
        }
        
        // Parse data rows
        const newFirms = [];
        for(let i = 1; i < lines.length; i++){
          const cols = parseCSVLine(lines[i]);
          const name = cols[nameIdx]?.trim();
          const address = cols[addressIdx]?.trim();
          const website = websiteIdx !== -1 ? (cols[websiteIdx]?.trim() || '') : '';
          
          if(name && address){
            newFirms.push({
              name,
              address,
              website,
              status: 'pending',
              lat: null,
              lon: null,
              resolved: '',
              error: '',
              lastQuery: '',
              lastStatus: '',
              _expanded: false
            });
          }
        }
        
        if(newFirms.length === 0){
          alert('No valid firms found in CSV.');
          return;
        }
        
        // Replace state with imported firms
        state.length = 0;
        state.push(...newFirms);
        
        // Clear markers
        if(vectorSource) vectorSource.clear();
        markerByKey.clear();
        
        // Apply any cached geocoding
        applyCache();
        render();
        
        alert(`Imported ${newFirms.length} firms.`);
      };
      reader.readAsText(file);
      e.target.value = ''; // Reset so same file can be re-imported
    });

    // Simple CSV line parser (handles quoted fields)
    function parseCSVLine(line){
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for(let i = 0; i < line.length; i++){
        const char = line[i];
        if(inQuotes){
          if(char === '"'){
            if(line[i+1] === '"'){
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else {
          if(char === '"'){
            inQuotes = true;
          } else if(char === ','){
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
      }
      result.push(current);
      return result;
    }

    const markerByKey = new Map();
    
    function coordKey(lat, lon){
      // Round to 5 decimal places (~1 meter precision) for grouping
      return `${lat.toFixed(5)},${lon.toFixed(5)}`;
    }
    
    function rebuildAllMarkers(){
      if (typeof ol === 'undefined' || !vectorSource) return;
      
      vectorSource.clear();
      markerByKey.clear();
      
      // Get all geocoded firms
      const geocodedFirms = state.filter(x => x.status === 'ok' && x.lat && x.lon);
      
      if(sameBuildingEnabled){
        // Group by coordinates
        const groups = new Map();
        for(const item of geocodedFirms){
          const key = coordKey(item.lat, item.lon);
          if(!groups.has(key)){
            groups.set(key, []);
          }
          groups.get(key).push(item);
        }
        
        // Create markers for each group
        for(const [key, items] of groups){
          // Sort alphabetically
          items.sort((a, b) => a.name.localeCompare(b.name));
          
          const isSelected = items.some(x => x._selected);
          const names = items.map(x => x.name).join('\n');
          const firmIds = items.map(x => x.id);
          
          const marker = new ol.Feature({
            geometry: new ol.geom.Point(ol.proj.fromLonLat([items[0].lon, items[0].lat])),
            name: names,
            firmIds: firmIds,
            firmId: firmIds[0], // Primary firm for selection
            selected: isSelected,
            isGroup: items.length > 1,
            groupCount: items.length
          });
          
          vectorSource.addFeature(marker);
          markerByKey.set(key, marker);
        }
      } else {
        // Individual markers
        for(const item of geocodedFirms){
          const marker = new ol.Feature({
            geometry: new ol.geom.Point(ol.proj.fromLonLat([item.lon, item.lat])),
            name: item.name,
            firmId: item.id,
            selected: item._selected,
            isGroup: false,
            groupCount: 1
          });
          
          vectorSource.addFeature(marker);
          markerByKey.set(cacheKeyFor(item), marker);
        }
      }
    }
    
    function upsertMarker(item){
      // Just rebuild all markers when same building grouping is enabled
      // This ensures groups are properly maintained
      rebuildAllMarkers();
    }


    function applyCache(){
      const cache = loadCache();
      for(const item of state){
        const key = cacheKeyFor(item);
        if(cache[key] && cache[key].lat && cache[key].lon){
          Object.assign(item, cache[key]);
          item.status = 'ok';
          item.error = '';
        }
      }
      rebuildAllMarkers();
    }

    function normalizeAddress(addr){
      let s = String(addr||'');
      s = s.replace(/\b\d+\s*F\b/gi,'');
      s = s.replace(/\bRoP\s*#?\d+\b/gi,'');
      s = s.replace(/\b#\d+\b/g,'');
      s = s.replace(/\b(Bldg\.?|Building|Tower|Hills|House|Gate|Plaza)\b/gi,'');
      s = s.replace(/\s+/g,' ').trim();
      s = s.replace(/\s*,\s*/g,', ');
      return s;
    }
    function stripLeadingBuilding(addr){
      const parts = String(addr||'').split(',').map(x=>x.trim()).filter(Boolean);
      if(parts.length<=1) return String(addr||'');
      if(!/\d/.test(parts[0]) && /\d/.test(parts[1])) return parts.slice(1).join(', ');
      return parts.join(', ');
    }
    function buildQueries(item){
      const raw = item.address||'';
      const a1 = raw;
      const a2 = stripLeadingBuilding(a1);
      const a3 = normalizeAddress(a2);
      const parts = a3.split(',').map(x=>x.trim()).filter(Boolean);
      const a4 = parts.filter(p => /\d/.test(p) || /-ku\b/i.test(p) || /tokyo\b/i.test(p) || /japan\b/i.test(p) || /\d{3}-\d{4}/.test(p)).join(', ');
      return [a1,a2,a3,a4, item.name + ', Tokyo, Japan', item.name + ', Japan'].map(x=>String(x||'').trim()).filter(Boolean);
    }

    function looksLikeHTML(text){
      const t = (text||'').trim().toLowerCase();
      return t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('checking your browser') || t.includes('cloudflare');
    }

    async function fetchJSONorText(url){
      const resp = await fetch(url, { headers: { 'Accept':'application/json' } });
      const ctype = (resp.headers.get('content-type')||'').toLowerCase();
      if(!resp.ok){
        const txt = await resp.text().catch(()=> '');
        return { ok:false, status:resp.status, ctype, text:txt };
      }
      if(ctype.includes('application/json')){
        const j = await resp.json();
        return { ok:true, status:resp.status, ctype, json:j };
      }
      const txt = await resp.text();
      return { ok:true, status:resp.status, ctype, text:txt };
    }

    function buildNominatimURL(endpoint, q){
      const base = endpoint.trim();
      const params = new URLSearchParams({
        format:'jsonv2',
        limit:'1',
        q:q,
        countrycodes:'jp,us',  // Support both Japan and US
        addressdetails:'1',
        'accept-language':'en'
      });
      return base + '?' + params.toString();
    }

    function buildMapboxURL(token, q){
      const params = new URLSearchParams({
        q: q,
        access_token: token,
        country: 'jp,us',  // Support both Japan and US
        limit: '1',
        language: 'en'
      });
      return 'https://api.mapbox.com/search/geocode/v6/forward?' + params.toString();
    }

    function parseNominatimResponse(data){
      if(Array.isArray(data) && data.length){
        const hit = data[0];
        return {
          lat: parseFloat(hit.lat),
          lon: parseFloat(hit.lon),
          resolved: hit.display_name || ''
        };
      }
      return null;
    }

    function parseMapboxResponse(data){
      if(data && data.features && data.features.length){
        const hit = data.features[0];
        const coords = hit.geometry?.coordinates;
        if(coords && coords.length >= 2){
          return {
            lat: coords[1],  // Mapbox returns [lon, lat]
            lon: coords[0],
            resolved: hit.properties?.full_address || hit.properties?.name || ''
          };
        }
      }
      return null;
    }

    async function geocodeOne(item, provider, endpoint, mapboxToken, retryCount = 0){
      item.error=''; item.lastQuery=''; item.lastStatus='';
      const queries = buildQueries(item);

      for(const q of queries){
        let url;
        if(provider === 'mapbox'){
          if(!mapboxToken){
            item.error = 'Mapbox access token is required. Get one at mapbox.com';
            item.status = 'no';
            return;
          }
          url = buildMapboxURL(mapboxToken, q);
        } else {
          url = buildNominatimURL(endpoint, q);
        }
        item.lastQuery = url;

        try{
          const r = await fetchJSONorText(url);
          item.lastStatus = `HTTP ${r.status} (${r.ctype || 'unknown'})`;

          if(!r.ok){
            item.error = `Geocoder HTTP error: ${r.status}` + (r.text ? ` — ${String(r.text).slice(0,160)}` : '');
            // Retry on rate limit with exponential backoff
            if((r.status === 429 || r.status === 403) && retryCount < 3){
              const backoff = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
              await new Promise(res => setTimeout(res, backoff));
              return geocodeOne(item, provider, endpoint, mapboxToken, retryCount + 1);
            }
            if(r.status === 429 || r.status === 403) return;
            continue;
          }

          if(r.text && looksLikeHTML(r.text)){
            item.error = 'Geocoder returned HTML (browser check / blocked). Try a different network, remove VPN, or switch geocoder endpoint.';
            return;
          }

          const data = r.json ? r.json : (r.text ? JSON.parse(r.text) : null);
          
          // Parse response based on provider
          const result = provider === 'mapbox' ? parseMapboxResponse(data) : parseNominatimResponse(data);
          
          if(result){
            item.lat = result.lat;
            item.lon = result.lon;
            item.resolved = result.resolved;
            item.status = 'ok';
            item.error = '';
            upsertMarker(item);

            const cache = loadCache();
            cache[cacheKeyFor(item)] = {
              lat: item.lat,
              lon: item.lon,
              resolved: item.resolved,
              lastStatus: item.lastStatus,
              lastQuery: item.lastQuery
            };
            saveCache(cache);
            return;
          }
        } catch(e){
          item.error = `Fetch failed: ${e && e.message ? e.message : String(e)}`;
          item.lastStatus = 'Fetch exception';
          // Retry on network errors
          if(retryCount < 3){
            const backoff = Math.pow(2, retryCount) * 1000;
            await new Promise(res => setTimeout(res, backoff));
            return geocodeOne(item, provider, endpoint, mapboxToken, retryCount + 1);
          }
          return;
        }

        await new Promise(r => setTimeout(r, 800));
      }

      item.status='no';
      item.error = item.error || 'No result after multiple query simplifications.';
    }

    let running = false;

    function updateProgress(current, total){
      const pct = total > 0 ? Math.round((current / total) * 100) : 0;
      elProgressStatus.textContent = `${current} / ${total}`;
      elProgressFill.style.width = `${pct}%`;
      elMiniProgressFill.style.width = `${pct}%`;
    }

    function showProgress(show){
      if(show){
        elProgressContainer.classList.add('active');
        elMiniProgress.classList.add('active');
      } else {
        elProgressContainer.classList.remove('active');
        elMiniProgress.classList.remove('active');
      }
    }

    async function runGeocoding(){
      if(running) return;
      running = true;

      // Reset ALL items to pending (true restart)
      for(const item of state){
        item.status='pending'; item.lat=null; item.lon=null; item.resolved='';
        item.error=''; item.lastQuery=''; item.lastStatus=''; item._expanded=false;
      }

      if (vectorSource) vectorSource.clear();
      markerByKey.clear();
      render();

      const provider = elGeocodeProvider.value;
      const endpoint = (elEndpoint.value || 'https://nominatim.openstreetmap.org/search').trim();
      const mapboxToken = elMapboxToken.value.trim();
      const delay = Math.max(50, parseInt(elDelay.value || '100', 10));
      const batchSize = Math.max(1, Math.min(50, parseInt(elBatchSize.value || '10', 10)));

      // Validate Mapbox token
      if(provider === 'mapbox' && !mapboxToken){
        showToast('Please enter a Mapbox access token');
        running = false;
        return;
      }

      const total = state.length;
      let processed = 0;

      showProgress(true);
      updateProgress(0, total);
      
      // Allow DOM to update
      await new Promise(r => requestAnimationFrame(r));

      // Process in batches
      for(let i = 0; i < state.length; i += batchSize){
        if(!running) break;
        
        const batch = state.slice(i, i + batchSize);
        
        // Mark batch as queued and render
        batch.forEach(item => { if(item.status === 'pending') item.status = 'queued'; });
        updateProgress(i, total);
        render();
        
        // Allow DOM to update
        await new Promise(r => requestAnimationFrame(r));
        
        // Run batch in parallel, update UI as each completes
        let batchCompleted = 0;
        await Promise.all(batch.map(async (item) => {
          if(!running) return;
          await geocodeOne(item, provider, endpoint, mapboxToken);
          if(item.status!=='ok') item.status='no';
          batchCompleted++;
          updateProgress(i + batchCompleted, total);
          render();
        }));
        
        processed = i + batch.length;
        
        // Delay between batches
        if(i + batchSize < state.length && running){
          await new Promise(r => setTimeout(r, delay));
        }
      }

      showProgress(false);

      const ok = state.filter(x => x.status==='ok' && x.lat && x.lon);
      if(ok.length && typeof ol !== 'undefined' && map){
        const extent = ol.extent.createEmpty();
        ok.forEach(x => {
          const coord = ol.proj.fromLonLat([x.lon, x.lat]);
          ol.extent.extend(extent, [coord[0], coord[1], coord[0], coord[1]]);
        });
        map.getView().fit(extent, { padding: [100, 100, 100, 100], duration: 500 });
      }

      running = false;
    }

    function stopGeocoding(){ 
      running = false; 
      showProgress(false);
    }

    elStart.addEventListener('click', ()=>{ running=false; setTimeout(runGeocoding, 50); });
    elStop.addEventListener('click', stopGeocoding);

    elClearCache.addEventListener('click', (e)=>{
      e.stopPropagation();
      
      // Clear localStorage cache
      localStorage.removeItem(CACHE_KEY);
      
      // Reset all state items
      for(let i = 0; i < state.length; i++){
        state[i].status = 'pending';
        state[i].lat = null;
        state[i].lon = null;
        state[i].resolved = '';
        state[i].error = '';
        state[i].lastQuery = '';
        state[i].lastStatus = '';
        state[i]._expanded = false;
        state[i]._selected = false;
      }
      selectedFirmId = null;
      
      // Clear all markers
      if(typeof ol !== 'undefined' && vectorSource){
        vectorSource.clear();
      }
      markerByKey.clear();
      
      // Re-render UI
      render();
      showToast('Cache cleared');
    });

    elTest.addEventListener('click', async ()=>{
      elTestOut.textContent = 'Running test...';
      const provider = elGeocodeProvider.value;
      const endpoint = (elEndpoint.value || 'https://nominatim.openstreetmap.org/search').trim();
      const mapboxToken = elMapboxToken.value.trim();
      const q = '5-1 Nibancho, Chiyoda City, Tokyo 102-0084, Japan';
      
      let url;
      if(provider === 'mapbox'){
        if(!mapboxToken){
          elTestOut.textContent = 'Error: Mapbox access token is required.\n\nGet your free token at https://account.mapbox.com/access-tokens/';
          return;
        }
        url = buildMapboxURL(mapboxToken, q);
      } else {
        url = buildNominatimURL(endpoint, q);
      }
      
      try{
        const r = await fetchJSONorText(url);
        const displayUrl = provider === 'mapbox' ? url.replace(mapboxToken, 'pk.***') : url;
        const head = `PROVIDER: ${provider}\nURL: ${displayUrl}\nSTATUS: HTTP ${r.status}\nCONTENT-TYPE: ${r.ctype || 'unknown'}\n`;
        let body = '';
        if(!r.ok) body = (r.text || '').slice(0, 700);
        else if(r.json) body = JSON.stringify(r.json, null, 2).slice(0, 700);
        else body = String(r.text || '').slice(0, 700);
        
        // Parse and show result
        let parsed = '';
        if(r.ok && r.json){
          const result = provider === 'mapbox' ? parseMapboxResponse(r.json) : parseNominatimResponse(r.json);
          if(result){
            parsed = `\n\nPARSED RESULT:\nLat: ${result.lat}\nLon: ${result.lon}\nAddress: ${result.resolved}`;
          }
        }
        
        elTestOut.textContent = head + '\nBODY (first 700 chars):\n' + body + parsed;
      } catch(e){
        elTestOut.textContent = 'Test failed: ' + (e && e.message ? e.message : String(e));
      }
    });

    applyCache();
    render();
    
    // Street View modal close handlers
    const svModal = document.getElementById('svModal');
    const svModalClose = document.getElementById('svModalClose');
    const svIframe = document.getElementById('svModalIframe');
    
    svModalClose.addEventListener('click', ()=>{
      svModal.classList.remove('open');
      svIframe.src = '';
    });
    
    svModal.addEventListener('click', (e)=>{
      if(e.target === svModal){
        svModal.classList.remove('open');
        svIframe.src = '';
      }
    });
    
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && svModal.classList.contains('open')){
        svModal.classList.remove('open');
        svIframe.src = '';
      }
    });
  </script>
</body>
</html>
